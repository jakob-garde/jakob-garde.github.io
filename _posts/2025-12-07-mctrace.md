---
title: "Building on Legacy"
---

# mctrace

*A few years ago I worked on the open-source software package McStas at DTU Physics (2015-2020). For the official project, see mccode.org. Recently I have been re-visiting the software package as a fun hobby and learning experience. The following is a reflection of my own personal opinions, and nothing more.*

Legacy software sometimes gets burried in layers of newer software.

That's certainly a good thing, because changing what's underneath can be risky. In the case of physics simulation code, obscure and disastrous 
bugs could be introduced. We'd rather build new features.

## What if re-visiting old code is exactly what unlocks new possibilities?

This project is a vertical slice. It is not an attempt to re-implement
existing functionality or achieve feature-parity as a baseline. Rather, it's an attempt to show what is possible.

It combines the functionality of three or four existing tools into one, and adds a number of new features and many more possibilities. It loads and runs much faster and distribution is simple.

Above all, it shows how to build completely new functionality, including features that would be very inconvenient to get in other ways.

The mctrace binary compiles from source and takes up a few MB for the executable, which is distributed along with a thin platform abstraction layer (glew/glfw). Due to the necessity of compiling on Windows with gcc, they couldn't be statically linked, but are included in the zip.

- Source: [mctrace]
- Win-x64 binary: [mctrace-win]

Essentially this is a port of the neutron scattering instrument called PSI_DMC and its fifteen components. Porting more to the mctrace format is not an issue, since the generic pipeline is there. As mentioned above however, this is a tech demo / vertical slice, not a complete port, so I focused on this simple and illustrative instrument for the project.

Code generation using my mcparse generator:

- Source: [mcparse]

The essential port takes place under the hood, but the most visible and attention-demanding is the visualization, and here's some fun examples:

### Example: Mouse-hover and selection boxes

When moving the mouse across the screen above a component, a box will appear around it, and its name is displayed in a tool-tip. By left-clicking, the component will become selected. This causes an info box to appear listing its name, type and parameter values.

When the Monitors tab is selected, a 1D or 2D plot is also displayed, showing current trace data. (NOTE: To see the plots, start the particle trace in the Simulation tab.)

![Sample monitor](/assets/10_mon_1D.png){: style=""}

### Example: Coloured rays by Lambda

As a fun visualization effect, I coloured the neutron trajectories by wavelength, which gives a nice effect when looking at the monochromator. (The monochromator is akin to a "prism" for visible light.)

You may notice that while rays of many colours hit the monochromator, only certain colours escape towards the sample component.

![Monochromator-autumn](/assets/04_mono.png){: style=""}
![Monochromator-jet](/assets/04b_monochromator_jet.png){: style=""}

### Example: Visualize particles that reach a component

If the trace button has been clicked in the Simulation tab, neutron trajectories will be shown in the trace tab. The shown "rays"/trajectories are a random selection of the particles that reach the selected component.

This lets us investigate sub-sets of the traced rays by clicking on various components. For example, try clicking the detector (the large banana-shaped component at the end of the instrument) to see a fan of rays escaping the sample.

![Sample beam](/assets/05_sample_ray.png){: style=""}
![Scattered](/assets/06_overview_detector.png){: style=""}


# List of Features

Below is a tentative list of the notable features implemented in this project. It is separated into three sections, showcasing the simulation core, visualization and code structure.

## Simulation engine

The legacy mccode simulation engine infrastructure has been re-implemented and modernized.

1) Components (tested on 15 ported components)

- generated .h files, one for each .comp file, wrapping create/init/trace/save/finally functions
- component base class (/header struct) used by the app layer for all component access
- generic parameter info available from the base component struct
- types: ported 15 components to C++
- type-agnostic wrapper for the above calls in a comps_meta.h
- transforms translation from 4x4 to legacy sim-compatible 3x3 + position

2) Instruments (tested for the PSI_DMC configurarion)

- one generated instument .h file for each .instr file with create/init/configure/finally functions
- generated specific instrument struct
- instrument wrapper struct / base class
- generated parameter hooks (name, value ptr)
- instrument initialization and configuration function with:
    - component creation and init
    - component transforms given instr params, comp params and AT/ROT with relative/absolute

3) Simulation

- particle propagation loop (runs in a worker thread)
- particle propagation pause/reset using the current instrument init
- simulation libraries re-packaged into simcore.h/simlib.h
- component display hooks: A callback fired by all components during DISPLAY
- component plot/monitor data hooks: A callback fired during SAVE
- particle trace "events" hooks: A callback for state/scatter/absorb events


## Visualization Engine

The instrument is viewed as component "display" wireframes in 3D combined with info-boxes.

1) Wireframe display

- component wireframes
- full instrument view of all components hovering above a scale grid
- component mouse-selection and next/prev component buttons
- 3D camera pan/zoom using the mouse
- dbl-click and enter-press to focus the camera view on the selected component
- mouse hover tooltip showing component name
- component selection infobox with name/type, absolute at/rot and current parameter values
- separate view modes for monitors vs. physical components
- nagivate the UI using left/right/tab/space key strokes

2) Monitor plot-data

- monitor 2D data written to texture arrays using color maps
- 1D and 2D monitor plot with component name and parameter values when selected
- 1D and 2D overview plots with component name
- component monitor data reset

3) Particle trajectories

- particle propagation with pause/reset runs in worker thread
- particle trace recording (state/scatter/absorb events)
- particle trajectories bundled by component-reached (non-biased)
- view particle trajectories by selecting a component


## Structural

The app compiles in less than a second with no intermediary build steps, and
it is easy to debug both the legacy component- and engine code, as well as the application layers.

1) Code structure

- minimal code-generated sections
- separate legacy, application and visualization layers
- eliminated most legacy globals, hereby enabling consecutive runs of arbitrary simulation configurations
- core simulation runtime libraries extracted into separate units that are included by default

2) Memory management

- instrument configuration state is layed-out sequentially in a localized "arena" containers
- containers also manage the lifetime of a trace-simulation
- separate instrument configs are managed individually with individual init/finally life cycles
- components often call malloc() during initialization and free() during finalize (unchanged)

3) Extensibility

- very easy to replace/tweak the particle propagation algorithm
- much improved optimization potential
- arbitrary and dynamic particle caching
- dynamic configurations that go beyond the DSL
- include arbitrary C++ code


4) Known Bugs

- the Monitor_nD component simply does not capture data as it should
- win touchpad can be wonky, mouse wheel is fine



[mctrace]: https://github.com/jakob-garde/mctrace
[mctrace-win]: https://github.com/jakob-garde/mctrace/raw/refs/heads/main/release/x64-win/mctrace-0.1.0.zip
[mcparse]: https://github.com/jakob-garde/mcparse


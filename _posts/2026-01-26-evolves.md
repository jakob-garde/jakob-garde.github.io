---
title: "Good Code Evolves from Clunky Code"
---

Ever thought to yourself; *Hold on, this code is objectively bad.* But you still don't feel bad about it? Then you might be on the right track to writing better code!

## Programming is a lot like writing

There's the well-known trick in writing of *don't edit, but edit later*. The idea is to get a draft on the page that can be improved into the final document.

In programming we have similar processes, for example code compression or [semantic compression](https://caseymuratori.com/blog_0015). Others like to talk about refactoring, or say *iterate and integrate*. In Denmark, a computer science meme demands that code must be written three times to be good:

When learning new things, experimenting with techniques and searching in broad strokes, we just don't know how best to write our program.

Once we have written that first version, we see major vectors of improvement. This calls for a re-write which results in a much better version-2, but having written the program twice, we now finally see the perfect third way, a flexible and simple path that solves everything elegantly. This calls for yet another re-write. Only when that is complete, will the program be considered as good as it can get (...)

Product owners tend to cringe when programmers talk about a re-write, and programmers tend to cringe when product owners request yet another un-planned feature update to legacy pasta. Of course, nobody wants un-maintainable spaghetti code.

Here is a possible path to badly structured code: The project was going great, we moved fast and iterated on an early version of code that the programmer hadn't written multiple times before. This lead to bad, early decisions getting locked-in for life.

Therefore we should consider front-loading some rewrites and refactoring work, long before it becomes absolutely necessary - or impossible.


## Procedural map generator

We are not getting into how it works. Instead, we are going to look at the process that brought the code from ugly to much better.

Recently I have been dabbling in game development using the graphics librari [raylib](https://www.raylib.com/cheatsheet/cheatsheet.html). It is not a full game engine so I get to learn how to write all juicy game logics myself. Procedural generation is very intesting and accessible, so I wrote a random map generator using wavefunction collapse.

Briefly, tiles are in a "superposition" of all outcomes. With each iteration, possible outcomes are reduced as neighbouring elements "collapse" into specific states and the map is complete. Eventually, every tile is resolved into one specific type.

Here's a demo: [wfc procgen](https://jakobgarde.itch.io/endless-forest-map-procgen-demo)

![wfc procgen](/assets/procgen_finished.png)


## Five stages of code

The implementation is only a few hundred lines, but it went through at least five stages of development over a few days:

- First working implementation
- Total re-write
- Refinement, abstraction
- Extension with new features
- Integration into the application environment

The end goal is a unit or mini-library that depends only on base layers. It should be easy for the app as a whole to integrate, and allow for straight-forward testing and porting to other projects.

The initial stage of getting the code working is crucial. That stage is called a "working implementation", and it positions us very well for refining it into better code. By that mean code that is simpler, smaller, more readable and easy to test and debug.

There is no way to "write code faster, better, the first time" without first writing that embarassingly ugly first working implementation.

Consider Gall's Law: "a working complex system is invariably found to have evolved from a simple system that worked". 1970's systems theory, a favourite decade of mine.

We could ship this first version if we didn't need more features on it - but as noted above, this is where spaghetti code comes from. Can we live with that? Maybe. Probably not.


### Stage 1: *The first, working version*

We write the thing in the most direct or immediate way that comes to mind. The goal is to bring the code into a working state without using abstractions beyond the bare minimum. We shouldn't try and think ahead at this point, just get it working.

Some basic test code is needed so that we can see what happens. In my case, I had a random map on the left, and the generated map on the right. I would step through iterations of the algorithm by pressing SPACE, and debug info was printed directly into the map on the screen as needed. This test method was carried over into consecutive stages.

Code: [wfc_stage_1.h](https://github.com/jakob-garde/endless/blob/main/article/wfc_stage_1.h)

<pre>
/*
First implementation:
- It works: A great starting point!
- The alg creates a tile map where flowers and rock tiles can not be adjacent
- Explicit, clunky implementation that is specific and verbose
- Tile superposition described as a clunky list of options
- About ~300 lines

Problems:
- Difficult to extend, multiple code edits requred
- Not usable, act as a learning step
- Out-commented code here and there
*/
</pre>

![wfc procgen](/assets/procgen_debug.png)

### Stage 2: *Total rewrite from scratch*

With the experience gainned from writing the initial version, we can now do it all again. Instead of modifying and debugging, we just start over. This allows the design the data and code structures to alleviate some of the pitfalls we encountered writing the first implementation.

The second stage should give the same output as the first.

Code: [wfc_stage_2.h](https://github.com/jakob-garde/endless/blob/main/article/wfc_stage_2.h)

<pre>
/*
Total re-implementation:
- Much clearer how the algorithm works
- Reduction matrix to describe what tiles can not be next to each-other
- Tile superposition described as an array of bools
- Grid initialization using one function; written to passed memory arena
- About ~200 lines

Problems:
- Clunky way to iterate the grid when "reducing" neighouring tile options
- Clunky way to get neighbouring tiles
- No recursive reduction will cause a bug in the future
- Reduction matrix isn't abstracted correctly*/
</pre>

### Stage 3: *Refactor and isolate complexity hotspots*

We should improve the second implementation version by means of refactoring and code compression.

At this stage the general code structure was ok, the clunkiness now being localized in implementations rather than baked into the superstructure. I prepared for the next stage by experimenting with the way that option exclusion was encoded (a complexity hotspot). Experiments also revealed the need for recursive update of auto-collapsed tiles.

Code: [wfc_stage_3.h](https://github.com/jakob-garde/endless/blob/main/article/wfc_stage_3.h)

<pre>
/*
Refactoring, finding serious bugs and refining:
- Adjacency matrix replaces "reducion" matrix
- Adjacency matrix has Directional adjacency rules (although they have no effect at this stage)
- Cleaner way to iterate tile neighbours: Using "kernel" arrays
- Recursive collapse of tiles that reach entropy == 1 (one option) to update their neighbours
- Uses much better variable names
- Clearly separated lib, user and debug-draw sections
- About ~220 lines from this point on

Problems: 
- Has the final serious bug: We collapse high-entropy tiles (incorrect) instead of low-entropy tiles
*/
</pre>

### Stage 4: *Extend with new features*

We now have a solid foundation to build out the necessary complexity for implementing the features we actually want.

Up until this stage, I was only working with three map tile types: Grass, flowers and rocks. Flowers and rocks could not be next to eachother, Now it was time to add five new til types: The forest tiles are: *up, down, left, right* and *inner*.

Adding the adjacency rules for these extra tile types revealed a serious bug: When it selected a random tile for collapse, it chose those which had the most options available. The contracty is intuitively correct, it should collapse the tiles with the least options / most constraints first. The generator worked almost perfectly after that change.

Finally the map with meadows and forest patches was generated correctly, I was happy with the features and looked to wrap it up.

Code: [wfc_stage_4.h](https://github.com/jakob-garde/endless/blob/main/article/wfc_stage_4.h)

<pre>
/*
Directional adjacency rules applied to procgen a map with connected forest tiles
- Directional adjacency rules active and working
- Activate and implement five forest tile types
- Select tiles to collapse by lowest-entropy rather than highest
- About 220 lines for the separated "lib" code section
- Correctly selects tiles to collapse using min-entropy
- Everything seems to work perfectly

Problems:
- Not fit for integration into an app - global variables, type names are too generic, no explicit draw function
- Adjacency rules are concise, but a little clunky to define (dontfix)
- Rare placement bug
*/
</pre>

### Stage 5: *Integration into the code base*

It is now time to think of the broader picture. How specific or general is this code? Are we using general names that might be misunderstood in the future?

For example, "Grid" should be named "WFCGrid" because it doesn't have any broader application. Also got rid of global variables that were convenient during implementation, but would certainly get in the way down the line. Global variables, badly implemented function and short-hand variable names: None of it really matters until we integrate / ship.

Code: [wfc_stage_5.h](https://github.com/jakob-garde/endless/blob/main/article/wfc_stage_5.h)

<pre>
/*
Integration:
- Rename types to be more specific
- Do not depend on global variables
- One function to run the algorithm (lib section)
- Function to apply draw-able frame object to tiles, a post-run step (draw section)
- Local user section is instead a few debug functions for potential future use
- User code is now in the app, we are calling it from the outside 
- Implementation of lib code is still about ~220 lines
- Draw function was copy-pasted and adapted in user code 

Problems: Can be changed later; and we are moving ahead at this point
- Wanted refactor: Tile type is not great for use in the app
- Wanted refactor: More convenient way of defining adjacency rules
- Wanted extension: A way to stitch separately generated regions created by the algorithm
- Wanted bugfix: Rare inconsistent placements can occur (research)
*/
</pre>


